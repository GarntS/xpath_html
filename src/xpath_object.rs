/* file:    xpath_object.rs
 * author:  garnt
 * date:    09/10/2024
 * desc:    XPath object representation.
*/

use crate::typer::{XPathType, XPathTypedOutput};
use crate::xpath_parser::{self, XPathParser};
use pest::Parser;
use std::error::Error;
use std::str::FromStr;

/// Pretty-prints a pest::Pair
fn pretty_print_pair<R: pest::RuleType>(pair: &pest::iterators::Pair<R>, depth: Option<usize>) {
    let depth: usize = depth.unwrap_or_default();
    println!(
        "{}{:?}: {}",
        " ".repeat(depth),
        pair.as_rule(),
        pair.as_str()
    );
    for sub_pair in pair.clone().into_inner() {
        pretty_print_pair(&sub_pair, Some(depth + 1));
    }
}

/// A single expression
#[derive(Debug, PartialEq)]
pub enum Expression {
    LogicalOrExpression {
        exprs: Vec<Box<Expression>>,
    },
    LogicalAndExpression {
        exprs: Vec<Box<Expression>>,
    },
    ComparisonExpression,
    StringConcatExpression,
    RangeExpression,
    AdditiveExpression,
    MultiplicativeExpression,
    UnionExpression {
        exprs: Vec<Box<Expression>>,
    },
    IntersectExceptExpression,
    InstanceofExpression,
    TreatExpression,
    CastableExpression,
    CastExpression,
    ArrowExpression,
    UnaryExpresson {
        is_negate: bool,
        rhs: Box<Expression>,
    },
    ValueExpression,
    SimpleMapExpression,
    PathExpresson,
    RelativePathExpression,
    StepExpression,
    PrimaryExpression,
}

/* TODO(garnt): implement
impl Expression {
    /// Parses an Expression from a pest::Pair object generated by the XPath
    /// parser.
    fn parse_from_pair<'a>(
        expr_single: pest::iterators::Pair<'a, xpath_parser::Rule>,
    ) -> Result<Self, String> {
        // match the inner and yield the result
        match expr_single.as_rule() {
            // Logical or expressions
            xpath_parser::Rule::or_expr => {
                let inner_pairs = expr_single.into_inner();
                assert!(inner_pairs.len() > 0);

                // if there's only one inner pair, it isn't really an or
                // expression, so fall through
                if inner_pairs.len() == 1 {
                    let inner = inner_pairs.next().unwrap();
                    return Expression::parse_from_pair(inner);
                } else {
                    // Parse each sub-expression leg of our 'or' into a Vec for
                    // evaluation
                    Ok(Self::LogicalOrExpression {
                        exprs: inner_pairs
                            .map(|pair| Box::new(Expression::parse_from_pair(pair)))
                            .collect()?,
                    })
                }
            }
            // Logical and expressions
            xpath_parser::Rule::and_expr => {
                let inner_pairs = expr_single.into_inner();
                assert!(inner_pairs.len() > 0);

                // if there's only one inner pair, it isn't really an or
                // expression, so fall through
                if inner_pairs.len() == 1 {
                    let inner = inner_pairs.next().unwrap();
                    return Expression::parse_from_pair(inner);
                } else {
                    // Parse each sub-expression leg of our and expression into
                    //  a Vec for evaluation
                    Ok(Self::LogicalAndExpression {
                        exprs: inner_pairs
                            .map(|pair| Box::new(Expression::parse_from_pair(pair)))
                            .collect()?,
                    })
                }
            }
            xpath_parser::Rule::comparison_expr => {}
            xpath_parser::Rule::string_concat_expr => {}
            xpath_parser::Rule::range_expr => {}
            // Additive (or subractive) expressions
            xpath_parser::Rule::additive_expr => {
                let inner_pairs = expr_single.into_inner();
                assert!(inner_pairs.len() > 0);

                if inner_pairs.len() == 1 {
                    // if there's only one inner pair, this isn't really an
                    // additive expression, so fall through
                    let inner = inner_pairs.next().unwrap();
                    return Expression::parse_from_pair(inner);
                } else {
                    // in this case, it really is an additive expression
                    // TODO(garnt): finish implementing
                    Ok()
                }
            }
            xpath_parser::Rule::multiplicative_expr => {}
            // Set union expressions
            xpath_parser::Rule::union_expr => {
                let inner_pairs = expr_single.into_inner();
                assert!(inner_pairs.len() > 0);

                // if there's only one inner pair, it isn't really an or
                // expression, so fall through
                if inner_pairs.len() == 1 {
                    let inner = inner_pairs.next().unwrap();
                    return Expression::parse_from_pair(inner);
                } else {
                    // Parse each sub-expression leg of our and expression into
                    //  a Vec for evaluation
                    Ok(Self::UnionExpression {
                        exprs: inner_pairs
                            .map(|pair| Box::new(Expression::parse_from_pair(pair)))
                            .collect()?,
                    })
                }
            }
            xpath_parser::Rule::intersect_except_expr => {}
            xpath_parser::Rule::instanceof_expr => {}
            xpath_parser::Rule::treat_expr => {}
            xpath_parser::Rule::castable_expr => {}
            xpath_parser::Rule::cast_expr => {}
            xpath_parser::Rule::arrow_expr => {}
            // Unary expressions
            xpath_parser::Rule::unary_expr => {
                let unary_start_col = expr_single.line_col().1;
                let inner_pair = expr_single.clone().into_inner().next().unwrap();
                let inner_start_col = expr_single.line_col().1;

                // if the unary expression and the inner pair start at the same
                // column, this isn't really a unary expression, so fall through
                if unary_start_col == inner_start_col {
                    return Expression::parse_from_pair(expr_single);
                } else {
                    // count the number of minus characters in the prefix. if
                    // the count is odd, this operation should negate the
                    // other value
                    let prefix_len: usize = inner_start_col - unary_start_col;
                    let n_minuses: usize = expr_single
                        .as_str()
                        .chars()
                        .take(prefix_len)
                        .filter(|char| *char == '-')
                        .count();
                    Ok(Self::UnaryExpresson {
                        is_negate: n_minuses % 2 != 0,
                        rhs: Box::new(Expression::parse_from_pair(inner_pair)?),
                    })
                }
            }
            xpath_parser::Rule::value_expr => {}
            xpath_parser::Rule::simple_map_expr => {}
            xpath_parser::Rule::path_expr => {}
            xpath_parser::Rule::relative_path_expr => {}
            xpath_parser::Rule::step_expr => {}
            xpath_parser::Rule::primary_expr => {}
            _ => Err("Expr".to_owned()),
        }
    }
}

impl XPathTypedOutput for Expression {
    /// Returns the output type for this object
    fn get_output_type(&self) -> XPathType {
        match self {
            Expression::LogicalOrExpression => XPathType::Boolean,
            Expression::LogicalAndExpression => XPathType::Boolean,
            Expression::ComparisonExpression => XPathType::Boolean,
            Expression::StringConcatExpression => XPathType::String,
            Expression::RangeExpression => XPathType::Sequence,
            // TODO(garnt): implement
            _ => panic!("unimplemented!"),
            /*Self::AdditiveExpression => XPathType::,
            Self::MultiplicativeExpression,
            Self::UnionExpression,
            Self::IntersectExceptExpression,
            Self::InstanceofExpression,
            Self::TreatExpression,
            Self::CastableExpression,
            Self::CastExpression,
            Self::ArrowExpression,
            Self::UnaryExpresson,
            Self::ValueExpression,
            Self::SimpleMapExpression,
            Self::PathExpresson,
            Self::RelativePathExpression,
            Self::StepExpression,
            Self::PrimaryExpression,*/
        }
    }
}*/

/// Represents the different axes that can be evaluated against
#[derive(Debug, PartialEq)]
pub enum AxisType {
    Ancestor,
    AncestorOrSelf,
    Attribute,
    Child,
    Descendant,
    DescendantOrSelf,
    Namespace,
    SelfAxis,
    Parent,
    Following,
    FollowingSibling,
    Preceding,
    PrecedingSibling,
    InvalidAxisType,
}

/// std::str::FromStr implementation for AxisType
impl FromStr for AxisType {
    type Err = ();

    fn from_str(input: &str) -> Result<AxisType, Self::Err> {
        match input {
            "ancestor" => Ok(AxisType::Ancestor),
            "ancestor-or-self" => Ok(AxisType::AncestorOrSelf),
            "attribute" => Ok(AxisType::Attribute),
            "child" => Ok(AxisType::Child),
            "descendant" => Ok(AxisType::Descendant),
            "descendant-or-self" => Ok(AxisType::DescendantOrSelf),
            "namespace" => Ok(AxisType::Namespace),
            "self" => Ok(AxisType::SelfAxis),
            "parent" => Ok(AxisType::Parent),
            "following" => Ok(AxisType::Following),
            "following-sibling" => Ok(AxisType::FollowingSibling),
            "preceding" => Ok(AxisType::Preceding),
            "preceding-sibling" => Ok(AxisType::PrecedingSibling),
            _ => Err(()),
        }
    }
}

/// Struct containing a parsed/evaluated xpath object
#[derive(Debug)]
pub struct XPath {}

// implementation for XPath
impl XPath {
    /// Returns a new, empty, XPath
    fn new() -> Self {
        XPath {}
    }

    /// Parses an XPath object from the provided string
    pub fn parse_from_str(xpath_str: &str) -> Result<Self, Box<dyn Error>> {
        println!("START");
        let mut parsed_pairs =
            xpath_parser::XPathParser::parse(xpath_parser::Rule::xpath, xpath_str)?;
        println!("PARSED");
        let base_pair = parsed_pairs
            .next()
            .expect("Parsed pairs contained no parsed XPaths!");

        // print our pair
        pretty_print_pair(&base_pair, None);

        // check we're parsing an xpath
        if base_pair.as_rule() != xpath_parser::Rule::xpath {
            return Err("Pair isn't an XPath!".into());
        }

        let mut out_xpath = XPath::new();

        // iterate over all the child nodes of expr_pair
        // TODO(garnt): uncomment
        /*for sub_pair in base_pair.into_inner() {
        if sub_pair.as_rule() == xpath_parser::Rule::expression {
            out_xpath
                .expressions
                .push(XPathExpression::parse_from_pair(sub_pair)?);
        }
        }*/

        // return the parsed XPath
        Ok(out_xpath)
    }
}
