wildcard       = { "*" }
quote          = { QUOTATION_MARK | "'" }
tag_identifier = { wildcard | ASCII_ALPHA+ }

// XPath literal values
str_literal  = { quote ~ (ASCII_ALPHANUMERIC | "_" | "-")* ~ quote }
uint_literal = { ASCII_DIGIT+ }
literal      = { str_literal | uint_literal }

// XPath function names
node_func_name            = { "name" | "text" | "lang" | "namespace-uri" | "count" | "position" | "last" }
bool_func_name            = { "not" }
string_func_name          = { "contains" | "starts-with" | "ends-with" | "concat" | "substring" | "substring-before" | "substring-after" | "translate" | "normalize-space" | "string-length" }
type_conversion_func_name = { "string" | "number" | "boolean" }
func_name                 = { node_func_name | bool_func_name | string_func_name | type_conversion_func_name }

// XPath operator literals
compare_op = { "!=" | "<=" | ">=" | "<" | ">" | "=" }
logic_op   = { "and" | "or" }

// XPath attribute statements
attr_name          = { ASCII_ALPHANUMERIC+ }
attr               = { "@" ~ attr_name }
attr_compare_block = { attr ~ WHITE_SPACE* ~ compare_op ~ WHITE_SPACE* ~ literal }

// XPath function calls
func_arg               = { attr | literal }
func_arg_separator     = { WHITE_SPACE* ~ "," ~ WHITE_SPACE* }
func_call              = { func_name ~ "(" ~ ((func_arg ~ func_arg_separator)* ~ (func_arg)*)? ~ ")" }
function_compare_block = { func_call ~ WHITE_SPACE* ~ compare_op ~ WHITE_SPACE* ~ literal }

// A single XPath selector
selector_clause = { attr_compare_block | function_compare_block | attr | func_call | ASCII_BIN_DIGIT+ }
selector_group  = { ("(" ~ selector_group ~ ")") | selector_clause ~ WHITE_SPACE+ ~ logic_op ~ WHITE_SPACE+ ~ selector_clause | selector_clause }
selector        = { "[" ~ selector_group ~ "]" }

// A single XPath step (XPaths alternate axes and steps)
terminal_step = { (tag_identifier ~ selector*) | attr }
step          = { tag_identifier ~ selector* }

// A single XPath axis (XPaths alternate axes and steps)
axis_name = { "ancestor-or-self" | "ancestor" | "attribute" | "child" | "descendant-or-self" | "descendant" | "namespace" | "self" | "parent" | "following-sibling" | "sibling" | "preceding-sibling" | "preceding" }
axis      = { ("//" | "/") ~ (axis_name ~ "::")? }

// A single XPath expression
xpath_expression = { (axis | step)+ ~ terminal_step? }
xpath            = { SOI ~ xpath_expression ~ (WHITE_SPACE* ~ "|" ~ WHITE_SPACE* ~ xpath_expression)* ~ EOI }
